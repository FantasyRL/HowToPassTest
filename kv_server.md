### 6.5840 实验2：键值服务器

#### 介绍
在本实验中，你将构建一个单机键值服务器，确保每个操作即使在网络故障的情况下也能精
确执行一次，并且操作是线性化的。后续实验将扩展该服务器以处理服务器崩溃。

#### 客户端与服务器交互
客户端可以向键值服务器发送三种不同的RPC：`Put(key, value)`、`Append(key, arg)`
和`Get(key)`。服务器维护一个键值对的内存映射。键和值都是字符串。`Put`用于
安装或替换特定键的值，`Append`将参数追加到键的值上并返回旧值，`Get`获取当前键的值。
如果键不存在，`Get`应返回空字符串，`Append`应将现有值视为零长度字符串。

#### 线性化
你的服务器必须确保对`Clerk`的`Get`/`Put`/`Append`方法的调用是线性化的。
如果客户端请求不是并发的，每个客户端调用应观察到之前调用所作的状态修改。对于并发调用，
返回值和最终状态必须与这些操作按某种顺序逐个执行时相同。调用是并发的如果它们在时间上
重叠：例如，如果客户端X调用`Clerk.Put()`，而客户端Y调用`Clerk.Append()`，然后客户
端X的调用返回。一个调用必须观察到所有在它开始之前已完成的调用的效果。

线性化对于应用程序是方便的，因为它是单个服务器一次处理一个请求的行为。
例如，如果一个客户端从服务器获得了更新请求的成功响应，那么其他客户端随后发
起的读取请求将保证看到该更新的效果。对于单个服务器，提供线性化是相对容易的。

#### 开始
我们提供了`src/kvsrv`中的框架代码和测试。你需要修改`kvsrv/client.go`、`kvsrv/server.go`和`kvsrv/common.go`。

执行以下命令启动：
```sh
$ cd ~/6.5840
$ git pull
$ cd src/kvsrv
$ go test
```

### 键值服务器在无网络故障情况下的实现（简单）

#### 任务
你的第一个任务是实现一个在无消息丢失情况下工作的解决方案。

#### 具体步骤
1. 在`client.go`中，添加RPC发送代码到Clerk的`Put`、`Append`和`Get`方法。
2. 在`server.go`中，实现`Put`、`Append`和`Get`的RPC处理程序。

#### 完成标准
当你通过测试套件的前两个测试：“一个客户端”和“多个客户端”时，任务完成。

#### 提示
使用`go test -race`检查你的代码是否无竞争条件。

### 键值服务器处理消息丢失（简单）

#### 任务
你需要修改解决方案以应对消息丢失（例如RPC请求和回复）。如果消息丢失，客户端的`ck.server.Call()`将返回`false`。每次调用`Clerk.Put()`或`Clerk.Append()`都应只执行一次，因此需要确保重发不会导致服务器重复执行请求。

#### 具体步骤
1. **客户端重试机制**：
    - 在`client.go`中，添加代码以在未收到回复时重试发送RPC请求。
2. **服务器处理重复请求**：
    - 在`server.go`中，添加代码以检测并过滤重复操作。
    - 唯一标识客户端操作，以确保每个操作仅执行一次。
    - 维护服务器状态以处理重复的`Get()`、`Put()`和`Append()`请求。

#### 提示
1. **客户端操作唯一标识**：通过唯一ID确保服务器执行每个操作仅一次。
2. **快速释放服务器内存**：例如，每个RPC请求隐含客户端已收到其前一个RPC的回复。假设客户端一次只会调用一个`Clerk`。

#### 示例测试输出
```sh
$ go test
Test: one client ...
  ... Passed -- t  3.8 nrpc 31135 ops 31135
Test: many clients ...
  ... Passed -- t  4.7 nrpc 102853 ops 102853
```

通过所有测试后，任务完成。
